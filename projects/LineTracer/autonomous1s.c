#pragma config(Sensor,		S2,			c2,            sensorEV3_Color)
#pragma config(Motor ,  motorA,         lm,            tmotorEV3_Large, PIDControl, driveLeft ,	encoder)
#pragma config(Motor ,  motorD,         rm,            tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int calcBound() {
	int bound;		// 경계값 변수
	int black = 0;	// 검은색 초기값 설정
	int white = 0;	// 흰색   초기값 설정

	//색깔 센서를 검은색 라인으로 위치
	//구동 초기 검은색 반사광 값 인식
	for (int i=0; i<5; i++) {
		black += getColorReflected(c2);
		sleep(10);
	}

	//색깔 센서를 흰색 라인으로 위치시키기 위해 로봇 회전
	//좌회전
	setMotorSpeed(lm,0);
	setMotorSpeed(rm,40);
	sleep(300);
	//정지
	setMotorSpeed(lm,0);
	setMotorSpeed(rm,0);

	//구동 초기 흰색   반사광 값 인식
	for (int i=0; i<5; i++){
		white += getColorReflected(c2);
		sleep(10);
	}

	//검은색과 흰색의 평균으로 경계값 설정
	bound = (black/5+white/5)/2;

	return bound;
}


task main()
{
int gray = calcBound();
// 무한 루프에서 색깔 센서로 측정한 반사광 값과 경계값을 비교하여, 로봇의 모터를 제어합니다.
while(1) {
	if (gray > getColorReflected(c2)) 
		{ /*센서로 감지한 값이 경계값보다 크면, 로봇은 검은색 영역 위에 있으므로 왼쪽 모터를 
		  강하게 돌려서 오른쪽으로 향하도록 합니다.*/
			setMotorSpeed(lm,50);
			setMotorSpeed(rm,10);
		}

	else 
	  { /*로봇은 흰색 영역 위에 있으므로 오른쪽 모터를 강하게 돌려서 왼쪽으로 향하도록 합니다.*/
	    setMotorSpeed(lm,10);
	    setMotorSpeed(rm,50);
	  }
	}
}
// 코드의 정확성은 주어진 로봇의 하드웨어 구성 및 센서의 캘리브레이션에 의존하기 때문에 
// 특정 환경에서 테스트해 보는 것이 중요합니다.